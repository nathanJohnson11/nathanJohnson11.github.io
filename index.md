---
layout: default
---

## Welcome

This ePortfolio integrates the knowledge and skills I gained and developed throughout my Computer Science program at Southern New Hampshire University (SNHU). It represents my growth in the program and showcases my abilities across key areas of computer science. The ePortfolio is designed to demonstrate my professional-quality technical skills and communication abilities in a coherent, technically sound manner.

### <u>Table of Content</u>

&nbsp;[Professional Self-Assessment](#self-assessment "Professional Self-Assessment")<br/>
&nbsp;[Refinement Plan and Code Review](#code-review "Refinement Plan and Code Review")<br/>
&nbsp;[Software Design and Engineering](#software-design "Software Design and Engineering")<br/>
&nbsp;[Algorithms and Data Structure](#algorithms "Algorithms and Data Structure")<br/>
&nbsp;[Databases](#databases "Databases")<br/>

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

<img id="self-assessment" src="assets/img/selfassessment.png" alt="Professional Self-Assessment" title="Professional Self-Assessment" />

## Professional Self-Assessment

Throughout my journey in the Computer Science program at Southern New Hampshire University, I have developed a comprehensive set of skills that have prepared me for success in the software development industry. This ePortfolio showcases my growth and expertise in key areas of computer science, including software engineering, algorithms and data structures, and database management.

My time in the Computer Science program has been one of continuous learning and improvement. Each course built upon the foundational concepts learned in previous classes, allowing me to develop a deep understanding of software development principles. Starting with basic programming concepts, I progressed through more complex topics such as object-oriented design, data structures, algorithm efficiency, database design, and software security.

The capstone course has been instrumental in bringing together everything I've learned into a cohesive portfolio that demonstrates my abilities as a software engineer. Through enhancing existing projects, I've been able to showcase my technical skills while also demonstrating my ability to collaborate, communicate effectively, and consider security in software design.

| **Technical Skills** | **Soft Skills** |
|:-----------:|:-----------:|
| C++ Programming | Problem Solving |
| Java Development | Critical Thinking |
| Python & MongoDB | Attention to Detail |
| OpenGL Graphics | Communication |
| Object-Oriented Design | Collaboration |
| Data Structures | Time Management |
| Algorithm Optimization | Organization |
| Database Management | Adaptability |

Collaboration is essential in modern software development. Throughout my coursework, I've participated in team-based projects that mirrored real-world development environments. I've learned to use version control systems like Git effectively, communicate technical concepts clearly to both technical and non-technical team members, and provide constructive code reviews to ensure code quality.

In my professional experience, I've worked in agile development environments, participating in daily stand-ups, sprint planning, and retrospectives. I understand the importance of clear communication, respect for diverse perspectives, and the need to balance individual contributions with team goals. These collaborative experiences have taught me how to be both an effective leader and a supportive team member.

Effective communication with stakeholders is crucial for project success. Throughout my academic career, I've developed the ability to translate complex technical concepts into language that non-technical stakeholders can understand. I've learned to create clear, professional documentation, deliver effective presentations, and adapt my communication style to different audiences.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

<img id="code-review" src="assets/img/codereview.png" alt="Code Review" title="Code Review" />

## Code Review

In the code review videos, I analyzed the three selected artifacts code for weaknesses, limitations, and vulnerabilities and explained my plan for enhancements. The code review is a walk-through of the existing source code and planned improvements to software design and engineering artifacts, algorithms and data structure, and databases. Through these videos, I demonstrate the critical elements of:

* Existing functionality: A detailed walk-through of the existing code focused on the features and function of the current code.
* Code Analysis: Target areas of improvement in structure, logic, efficiency, functionality, security, testing, commenting, and documenting.
* Enhancements: A walk-through of planned enhancements that address issues raised in the code analysis.

### Software Design and Engineering Enhancements

The artifact selected for the software design and engineering code review is the **3D Scene Application**. The application was planned, designed, and developed as part of the computer science course CS 330: Computational Graphics and Visualization. The program renders a 3D scene with textured objects, dynamic lighting, and camera movement controls. I developed the application in C++ using OpenGL. The enhancement planned to implement is to refactor the code using proper object-oriented design principles, creating a clear class hierarchy, and improving code organization.

<div style="text-align: center;">
    <div style="position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;">
        <iframe style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;" src="https://youtu.be/m-xxEpfoQsI?feature=shared&t=42" title="Code Review: Software Design and Engineering Artifact" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    </div>
    <p><em>Figure 1 - Software Design and Engineering Code Review Video</em></p>
</div>

### Algorithms and Data Structure Enhancements

The code review in algorithms and data structure is the artifact of the **Contact Service**. The program was planned, designed, and developed as part of the CS 320: Software Testing, Automation, and Quality Assurance computer science course. The program aims to create a contact management system with CRUD functionality. The program is developed in the Java programming language. The enhancement planned to implement is to replace the ArrayList-based storage with a HashMap for O(1) lookup operations, optimize the update function, and improve error handling and validation.

<div style="text-align: center;">
    <div style="position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;">
        <iframe style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;" src="https://youtu.be/m-xxEpfoQsI?feature=shared&t=267" title="Code Review: Algorithms and Data Structure Artifact" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    </div>
    <p><em>Figure 2 - Algorithms and Data Structure Code Review Video</em></p>
</div>

### Databases Enhancements

The code review in databases is the artifact of **Animal Shelter Database Interface**. The program was planned, designed, and developed for the CS 340 Client-Server Development computer science course. The application aims to create a database interface that connects to MongoDB for managing animal shelter data. The application is developed in Python with the PyMongo driver. The planned enhancement is to implement environment variables for database credentials, add comprehensive error handling and logging, optimize queries with database indexes, and create a unit testing framework.

<div style="text-align: center;">
    <div style="position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;">
        <iframe style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;" src="https://youtu.be/m-xxEpfoQsI?feature=shared&t=513" title="Code Review: Databases Artifact" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    </div>
    <p><em>Figure 3 - Databases Code Review Video</em></p>
</div>

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

<img id="software-design" src="assets/img/softwaredesign.png" alt="Software Design and Engineering" title="Software Design and Engineering" />

## Software Design and Engineering

I chose a 3D graphics project from CS 330: Computational Graphics and Visualization. This program, built in C++ with OpenGL, renders a fully navigable three-dimensional world. It features textured objects, dynamic lighting, and realistic shading. Users can move freely through the scene, looking at objects from any angle while the lighting shifts in real time. The program uses ambient and directional lighting models, along with texture mapping, to create an immersive experience that reacts to user input.

This artifact involves proper software design and object-oriented principles. The program worked, but the code was a mess. The main file was bloated with vertex and index generators for different shapes, making it hard to follow. Global variables were scattered everywhere, making it nearly impossible to track data changes. I tackled the problem by refactoring the code and creating a proper class hierarchy. I built a base Shape class and derived classes for specific shapes like Cube, along with specialized types like Light. This restructuring pulled the vertex and index generators into their respective classes, making the code far more organized.

<div style="text-align: center;">
    <img src="assets/img/3DScene_Screenshot.png" width="800px" title="3D Scene Application Screenshot" />
    <p><em>Figure 4 - 3D Scene with Base Shape Class and Derived Classes</em></p>
</div>

The implemented design creates a stronger coding environment by restructuring and modularizing the code. Each shape now has its own defined space, a class that holds not just its form but its behavior. It's now like each of the items is properly stored on shelves rather than scattered across a floor. These shapes are easier to find, maintain, and modify when they each have a designated place in the architecture. Through implementing constructors that accept size parameters, I enhanced the flexibility of shape creation in the program. The Cube class constructor now takes a cubeSize parameter that determines the dimensions of generated vertices.

<div style="text-align: center;">
    <img src="assets/img/3DScene_ClassDiagram.png" width="600px" title="Class Hierarchy Diagram" />
    <p><em>Figure 5 - Class Hierarchy After Refactoring</em></p>
</div>

Classes lock data away while global variables leave everything exposed. Security comes down to controlling who can access what. Private data stays protected, but public data can be changed by anyone. Getters and setters create safe pathways to access information. This professional approach isn't just theoretical, it's practical. The system can now handle new shapes of different sizes without major rewrites. The code also adapts to new needs without extensive modifications to the core system.

Isolation matters in software design. When shapes live in their own classes, problems stay contained within clear boundaries instead of spreading throughout the codebase. Bugs have fewer places to hide, and changes to one component hurt less because they don't ripple through the entire system. OpenGL and object design don't naturally work together. OpenGL needs state while objects need independence. Finding balance between them was the main challenge. Testing each piece after changes kept the program working correctly. Over time, messy code became organized design. The program runs better now and is easier to update.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

<img id="algorithms" src="assets/img/algorithms.png" alt="Algorithms and Data Structure" title="Algorithms and Data Structure" />

## Algorithms and Data Structure

I chose a contact management system from CS 320. This program, built in Java, handles a database of contacts with core CRUD functionality. It stores personal information like names, phone numbers, and addresses. Users can add new contacts, update existing information, delete contacts, and retrieve specific records by ID. The original implementation used an ArrayList-based storage system that worked adequately for small datasets but would struggle with larger collections of contacts.

This artifact demonstrates algorithm and data structure optimization. The contact system worked, but performance was an issue. The ArrayList implementation meant every operation required scanning through the entire list, making searches slow as contact numbers grew. I improved the system by replacing the ArrayList with a HashMap for contact storage. Using contact IDs as keys dramatically improved lookup speed. This change reduced search, update, and delete operations from O(n) time complexity to O(1), making the system much faster. While an ArrayList needs to check every contact until it finds the right one, a HashMap jumps straight to the correct record.

<div style="text-align: center;">
    <img src="assets/img/ContactService_Complexity.png" width="600px" title="Time Complexity Comparison" />
    <p><em>Figure 6 - Time Complexity Comparison: ArrayList vs HashMap</em></p>
</div>

The implemented optimization improves the design and evaluation of computing solutions that solve a given problem using algorithmic principles and computer science practices. Through optimizing the update function, I made the system more efficient by only changing what's different. The old code replaced everything every time. Now it only updates what actually changed. This saves time and keeps things running smooth, especially when just changing one small detail. The Contact class already had validation in the constructor, but I improved how the service layer works with it to maintain data integrity throughout the system's operation.

<div style="text-align: center;">
    <img src="assets/img/ContactService_Architecture.png" width="600px" title="Contact Service Architecture" />
    <p><em>Figure 7 - Optimized Contact Service Architecture</em></p>
</div>

Data structures matter in algorithm design. A HashMap gives immediate access without searching the entire collection. This approach isn't just theoretical, it's practical. The system can now handle larger contact databases without slowing down. The code also adapts to new requirements more easily because of its more modular design and improved error handling system. I put in better error checks too. The system tests contact IDs and other fields before accepting changes. When something's wrong, it says exactly what the problem is instead of just failing.

Performance matters in software development. When contacts are stored in a HashMap, operations stay high-speed even as the database grows. Searches don't get slower with more contacts, and updates happen immediately because the system knows exactly where to look. Time complexity and space requirements don't always align. HashMaps need more memory than arrays, but they save tremendous time. Finding this balance was the main challenge. The program handles larger datasets now and responds much faster. This project taught me how important data structure selection is for any software engineer working with data-intensive applications.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

<img id="databases" src="assets/img/databases.png" alt="Databases" title="Databases" />

## Databases

I chose a database interaction module from CS 340 called animal_shelter.py. This program, built in Python, connects to a MongoDB database and manages animal shelter data. It provides basic CRUD operations (Create, Read, Update, Delete) for adding new animal records, updating existing information, deleting records, and retrieving specific data. The original implementation used hardcoded database credentials and had minimal error handling. The program successfully connected to the database and performed basic functions but lacked security features and performance optimizations needed in a real production environment.

This artifact involves the engineering of practices of validating input data and architect and design with default denial when accessing databases records. This skill develops a security mindset that anticipates adversarial exploits in software architecture and designs to expose potential vulnerabilities, mitigate design flaws, and ensure privacy and enhanced security of data and resources. I improved the system by replacing hardcoded credentials with environment variables. This makes the application more secure by keeping sensitive information out of the source code. Now credentials can be managed separately for different environments.

<div style="text-align: center;">
    <img src="assets/img/AnimalShelter_Demo.png" width="800px" title="Animal Shelter Database Interface Demo" />
    <p><em>Figure 8 - Animal Shelter Database Interface Demonstration</em></p>
</div>

The implemented data structure is programmatic, where the stored variable values can be used efficiently in different functions and operations. This approach improves the design and evaluation of computing solutions that solve a given problem using algorithmic principles and computer science practices and standards appropriate to its solution, while managing the trade-offs involved in design choices. I added comprehensive error handling with try-except blocks around database operations. The enhanced code now catches specific MongoDB exceptions and provides clear error messages. I also added logging functionality that records errors, warnings and successful operations.

<div style="text-align: center;">
    <img src="assets/img/AnimalShelter_Architecture.png" width="700px" title="Animal Shelter Database Architecture" />
    <p><em>Figure 9 - Animal Shelter Database Architecture</em></p>
</div>

Database security matters in software development. When credentials are stored as environment variables, they're protected from accidental exposure in source control. Through adding unit tests for all CRUD operations, I made the system more reliable. The tests use a separate test database to avoid affecting real data and include setup and teardown methods. I put in database indexing too. By adding indexes to frequently queried fields using MongoDB's createIndex() method, searches are much faster, especially for operations filtering on common fields like breed and location.

The enhancements I made to this artifact demonstrate my ability to develop professional database interfaces that prioritize security, reliability, and performance. Error handling proved more complex than expected. MongoDB can throw different types of exceptions, and properly catching each type required studying both Python's exception system and MongoDB's error documentation. The enhanced database module now has the security, reliability, and performance features needed for a real production environment. This project taught me how important query optimization is for database systems, and how important a skill it is for any software engineer working with data-intensive applications.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
