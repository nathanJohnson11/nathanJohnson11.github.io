---
layout: default
---

## Welcome

This ePortfolio integrates the knowledge and skills I gained and developed throughout my Computer Science program at Southern New Hampshire University (SNHU). It represents my growth in the program and showcases my abilities across key areas of computer science. The ePortfolio is designed to demonstrate my professional-quality technical skills and communication abilities in a coherent, technically sound manner.

### <u>Table of Content</u>

&nbsp;[Professional Self-Assessment](#self-assessment "Professional Self-Assessment")<br/>
&nbsp;[Course Outcomes](#course-outcomes "Course Outcomes")<br/>
&nbsp;[Code Review](#code-review "Code Review")<br/>
&nbsp;[Software Design and Engineering](#software-design "Software Design and Engineering")<br/>
&nbsp;[Algorithms and Data Structure](#algorithms "Algorithms and Data Structure")<br/>
&nbsp;[Databases](#databases "Databases")<br/>

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

<img id="self-assessment" src="assets/img/selfassessment.png" alt="Professional Self-Assessment" title="Professional Self-Assessment" />

## Professional Self-Assessment

Looking back on my time in the Computer Science program, I can say I’ve grown a lot, both in how I write code and in how I approach problems. Before starting this degree, I had a decent foundation, but now I’ve got a much stronger handle on things like software engineering, algorithms, database design, and working on a team in a real-world way. I’ve learned how to build better systems, write more maintainable code, and communicate more clearly with both technical folks and non-technical stakeholders.

One thing that stands out from the capstone course is how it tied everything together. Going back to past projects and enhancing them gave me a chance to reflect on how far I’ve come. I saw firsthand how my early work could be improved, not just in how it runs, but also in how it reads and how it holds up when changes need to be made. It showed me how important clean structure, security, and design really are. The capstone wasn’t just a review, it was a chance to apply what I’ve learned across the board.

When I picked out my artifacts to enhance, I chose projects that show different sides of what I’ve learned: software design, data structures and algorithms, and database development. These three areas are big pillars of what employers look for in a developer, and I wanted to show I can handle each of them. I went back into those projects and focused on improving readability, performance, security, and user experience, making sure they weren’t just functional, but polished and professional.

Along the way, I’ve developed a good amount of confidence when it comes to version control and team collaboration. Using Git and GitHub became second nature to me, especially through courses that used Agile workflows. I also had to write documentation and status updates, which helped me get better at communicating with others, whether that’s teammates, instructors, or stakeholders who might not have a technical background. I’ve learned how to explain things clearly and keep everyone on the same page.

Security became more important to me too. In one of the artifacts I enhanced, I took time to harden the database against SQL injection by using prepared statements and better validation. That focus came out of the secure coding and cybersecurity classes I took, where I learned how easy it is for overlooked code to create big problems. I don’t just think about whether something works anymore, I think about whether it’s safe and maintainable too.

I also improved my time management and adaptability during this program. There were plenty of assignments where I had to learn new tools or figure out unfamiliar concepts under tight deadlines. That kind of problem-solving and flexibility is something I know employers care about, and I’ve had a lot of practice with it now. Whether I’m writing a recursive algorithm, designing a user interface, or organizing a database schema, I’ve learned how to break the problem down and come up with solid, reliable solutions.

All in all, this program gave me the technical foundation and the real-world experience I needed to be ready for a software development job. I know how to plan and build full systems, how to work in a team setting, and how to keep learning as technology changes. The capstone helped me pull all of it together and show how far I’ve come, and I feel ready to take the next step into the professional world.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

## Course Outcomes
### Across my ePortfolio, through both the artifacts and their narratives, I demonstrate key skills and knowledge that align with the following outcomes:
- I Employ strategies for building collaborative environments that enable diverse audiences to support organizational decision making in the field of computer science
  - I Design, develop, and deliver professional-quality oral, written, and visual communications that are coherent, technically sound, and appropriately adapted to specific audiences and contexts
  - I Design and evaluate computing solutions that solve a given problem using algorithmic principles and computer science practices and standards appropriate to its solution, while managing the trade-offs involved in design choices
  - I Demonstrate an ability to use well-founded and innovative techniques, skills, and tools in computing practices for the purpose of implementing computer solutions that deliver value and accomplish industry-specific goals
  - I Develop a security mindset that anticipates adversarial exploits in software architecture and designs to expose potential vulnerabilities, mitigate design flaws, and ensure privacy and enhanced security of data and resources

Here is a the complete narratives on how I achieved these outcomes [(Click Here)](https://github.com/nathanJohnson11/nathanJohnson11.github.io/tree/main/narratives)

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

<img id="code-review" src="assets/img/codereview.png" alt="Code Review" title="Code Review" />

## Code Review

In the code review videos, I analyzed the three selected artifacts code for weaknesses, limitations, and vulnerabilities and explained my plan for enhancements. The code review is a walk-through of the existing source code and planned improvements to software design and engineering artifacts, algorithms and data structure, and databases. Through these videos, I demonstrate the critical elements of:

* Existing functionality: A detailed walk-through of the existing code focused on the features and function of the current code.
* Code Analysis: Target areas of improvement in structure, logic, efficiency, functionality, security, testing, commenting, and documenting.
* Enhancements: A walk-through of planned enhancements that address issues raised in the code analysis.

### Software Design and Engineering Enhancements

The artifact selected for the software design and engineering code review is the **3D Scene Application**. The application was planned, designed, and developed as part of the computer science course CS 330: Computational Graphics and Visualization. The program renders a 3D scene with textured objects, dynamic lighting, and camera movement controls. I developed the application in C++ using OpenGL. The enhancement planned to implement is to refactor the code using proper object-oriented design principles, creating a clear class hierarchy, and improving code organization.

<div style="text-align: center;">
    <div style="position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;">
        <iframe style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;" 
                src="https://www.youtube.com/embed/m-xxEpfoQsI?start=42" 
                title="Software Design and Engineering Code Review Video" 
                frameborder="0" 
                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" 
                referrerpolicy="strict-origin-when-cross-origin" 
                allowfullscreen>
        </iframe>
    </div>
    <p><em>Figure 1 - Software Design and Engineering Code Review Video</em></p>
</div>

### Algorithms and Data Structure Enhancements

The code review in algorithms and data structure is the artifact of the **Contact Service**. The program was planned, designed, and developed as part of the CS 320: Software Testing, Automation, and Quality Assurance computer science course. The program aims to create a contact management system with CRUD functionality. The program is developed in the Java programming language. The enhancement planned to implement is to replace the ArrayList-based storage with a HashMap for O(1) lookup operations, optimize the update function, and improve error handling and validation.

<div style="text-align: center;">
    <div style="position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;">
        <iframe style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;" 
                src="https://www.youtube.com/embed/m-xxEpfoQsI?start=269" 
                title="Algorithms and Data Structure Code Review Video" 
                frameborder="0" 
                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" 
                referrerpolicy="strict-origin-when-cross-origin" 
                allowfullscreen>
        </iframe>
    </div>
    <p><em>Figure 2 - Algorithms and Data Structure Code Review Video</em></p>
</div>

### Databases Enhancements

The code review in databases is the artifact of **Animal Shelter Database Interface**. The program was planned, designed, and developed for the CS 340 Client-Server Development computer science course. The application aims to create a database interface that connects to MongoDB for managing animal shelter data. The application is developed in Python with the PyMongo driver. The planned enhancement is to implement environment variables for database credentials, add comprehensive error handling and logging, optimize queries with database indexes, and create a unit testing framework.

<div style="text-align: center;">
    <div style="position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;">
        <iframe style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;" 
                src="https://www.youtube.com/embed/m-xxEpfoQsI?start=514" 
                title="Databases Code Review Video" 
                frameborder="0" 
                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" 
                referrerpolicy="strict-origin-when-cross-origin" 
                allowfullscreen>
        </iframe>
    </div>
    <p><em>Figure 3 - Databases Code Review Video</em></p>
</div>

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

<img id="software-design" src="assets/img/softwaredesign.png" alt="Software Design and Engineering" title="Software Design and Engineering" />

## Software Design and Engineering

I chose a 3D graphics project from CS 330: Computational Graphics and Visualization. This program, built in C++ with OpenGL, renders a fully navigable three-dimensional world. It features textured objects, dynamic lighting, and realistic shading. Users can move freely through the scene, looking at objects from any angle while the lighting shifts in real time. The program uses ambient and directional lighting models, along with texture mapping, to create an immersive experience that reacts to user input.

This artifact involves proper software design and object-oriented principles. The program worked, but the code was a mess. The main file was bloated with vertex and index generators for different shapes, making it hard to follow. Global variables were scattered everywhere, making it nearly impossible to track data changes. I tackled the problem by refactoring the code and creating a proper class hierarchy. I built a base Shape class and derived classes for specific shapes like Cube, along with specialized types like Light. This restructuring pulled the vertex and index generators into their respective classes, making the code far more organized.

<div style="text-align: center;">
    <img src="assets/img/3DScene_Screenshot.png" width="800px" title="3D Scene Application Screenshot" />
    <p><em>Figure 4 - 3D Scene with Base Shape Class and Derived Classes</em></p>
</div>

The implemented design creates a stronger coding environment by restructuring and modularizing the code. Each shape now has its own defined space, a class that holds not just its form but its behavior. It's now like each of the items is properly stored on shelves rather than scattered across a floor. These shapes are easier to find, maintain, and modify when they each have a designated place in the architecture. Through implementing constructors that accept size parameters, I enhanced the flexibility of shape creation in the program. The Cube class constructor now takes a cubeSize parameter that determines the dimensions of generated vertices.

<div style="text-align: center;">
    <img src="assets/img/3DScene_ClassDiagram.png" width="600px" title="Class Hierarchy Diagram" />
    <p><em>Figure 5 - Class Hierarchy After Refactoring</em></p>
</div>

Classes lock data away while global variables leave everything exposed. Security comes down to controlling who can access what. Private data stays protected, but public data can be changed by anyone. Getters and setters create safe pathways to access information. This professional approach isn't just theoretical, it's practical. The system can now handle new shapes of different sizes without major rewrites. The code also adapts to new needs without extensive modifications to the core system.

Isolation matters in software design. When shapes live in their own classes, problems stay contained within clear boundaries instead of spreading throughout the codebase. Bugs have fewer places to hide, and changes to one component hurt less because they don't ripple through the entire system. OpenGL and object design don't naturally work together. OpenGL needs state while objects need independence. Finding balance between them was the main challenge. Testing each piece after changes kept the program working correctly. Over time, messy code became organized design. The program runs better now and is easier to update.

---

Artifact enhancement files repository at [Software Design and Engineering - 3D Scene Enhancement](https://github.com/nathanJohnson11/nathanJohnson11.github.io/tree/main/artifacts/Enhanced/CS330%20-%20Software%20Design%20and%20Engineering "View Enhanced Source Code")

---
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

<img id="algorithms" src="assets/img/algorithms.png" alt="Algorithms and Data Structure" title="Algorithms and Data Structure" />

## Algorithms and Data Structure

I chose a contact management system from CS 320. This program, built in Java, handles a database of contacts with core CRUD functionality. It stores personal information like names, phone numbers, and addresses. Users can add new contacts, update existing information, delete contacts, and retrieve specific records by ID. The original implementation used an ArrayList-based storage system that worked adequately for small datasets but would struggle with larger collections of contacts.

This artifact demonstrates algorithm and data structure optimization. The contact system worked, but performance was an issue. The ArrayList implementation meant every operation required scanning through the entire list, making searches slow as contact numbers grew. I improved the system by replacing the ArrayList with a HashMap for contact storage. Using contact IDs as keys dramatically improved lookup speed. This change reduced search, update, and delete operations from O(n) time complexity to O(1), making the system much faster. While an ArrayList needs to check every contact until it finds the right one, a HashMap jumps straight to the correct record.

<div style="text-align: center;">
    <img src="assets/img/ContactService_Complexity.png" width="600px" title="Time Complexity Comparison" />
    <p><em>Figure 6 - Time Complexity Comparison: ArrayList vs HashMap</em></p>
</div>

The implemented optimization improves the design and evaluation of computing solutions that solve a given problem using algorithmic principles and computer science practices. Through optimizing the update function, I made the system more efficient by only changing what's different. The old code replaced everything every time. Now it only updates what actually changed. This saves time and keeps things running smooth, especially when just changing one small detail. The Contact class already had validation in the constructor, but I improved how the service layer works with it to maintain data integrity throughout the system's operation.

<div style="text-align: center;">
    <img src="assets/img/ContactService_Architecture.png" width="600px" title="Contact Service Architecture" />
    <p><em>Figure 7 - Optimized Contact Service Architecture</em></p>
</div>

Data structures matter in algorithm design. A HashMap gives immediate access without searching the entire collection. This approach isn't just theoretical, it's practical. The system can now handle larger contact databases without slowing down. The code also adapts to new requirements more easily because of its more modular design and improved error handling system. I put in better error checks too. The system tests contact IDs and other fields before accepting changes. When something's wrong, it says exactly what the problem is instead of just failing.

Performance matters in software development. When contacts are stored in a HashMap, operations stay high-speed even as the database grows. Searches don't get slower with more contacts, and updates happen immediately because the system knows exactly where to look. Time complexity and space requirements don't always align. HashMaps need more memory than arrays, but they save tremendous time. Finding this balance was the main challenge. The program handles larger datasets now and responds much faster. This project taught me how important data structure selection is for any software engineer working with data-intensive applications.

---

Artifact enhancement files repository at [Algorithms and Data Structure - Contact Service Enhancement](https://github.com/nathanJohnson11/nathanJohnson11.github.io/tree/main/artifacts/Enhanced/CS320%20-%20Algorithms%20and%20Data%20Structure "View Enhanced Source Code")

---
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

<img id="databases" src="assets/img/databases.png" alt="Databases" title="Databases" />

## Databases

I chose a database interaction module from CS 340 called animal_shelter.py. This program, built in Python, connects to a MongoDB database and manages animal shelter data. It provides basic CRUD operations (Create, Read, Update, Delete) for adding new animal records, updating existing information, deleting records, and retrieving specific data. The original implementation used hardcoded database credentials and had minimal error handling. The program successfully connected to the database and performed basic functions but lacked security features and performance optimizations needed in a real production environment.

This artifact involves the engineering of practices of validating input data and architect and design with default denial when accessing databases records. This skill develops a security mindset that anticipates adversarial exploits in software architecture and designs to expose potential vulnerabilities, mitigate design flaws, and ensure privacy and enhanced security of data and resources. I improved the system by replacing hardcoded credentials with environment variables. This makes the application more secure by keeping sensitive information out of the source code. Now credentials can be managed separately for different environments.

<div style="text-align: center;">
    <img src="assets/img/AnimalShelter_Demo.png" width="800px" title="Animal Shelter Database Interface Demo" />
    <p><em>Figure 8 - Animal Shelter Database Interface Demonstration</em></p>
</div>

The implemented data structure is programmatic, where the stored variable values can be used efficiently in different functions and operations. This approach improves the design and evaluation of computing solutions that solve a given problem using algorithmic principles and computer science practices and standards appropriate to its solution, while managing the trade-offs involved in design choices. I added comprehensive error handling with try-except blocks around database operations. The enhanced code now catches specific MongoDB exceptions and provides clear error messages. I also added logging functionality that records errors, warnings and successful operations.

<div style="text-align: center;">
    <img src="assets/img/AnimalShelter_Architecture.png" width="700px" title="Animal Shelter Database Architecture" />
    <p><em>Figure 9 - Animal Shelter Database Architecture</em></p>
</div>

Database security matters in software development. When credentials are stored as environment variables, they're protected from accidental exposure in source control. Through adding unit tests for all CRUD operations, I made the system more reliable. The tests use a separate test database to avoid affecting real data and include setup and teardown methods. I put in database indexing too. By adding indexes to frequently queried fields using MongoDB's createIndex() method, searches are much faster, especially for operations filtering on common fields like breed and location.

The enhancements I made to this artifact demonstrate my ability to develop professional database interfaces that prioritize security, reliability, and performance. Error handling proved more complex than expected. MongoDB can throw different types of exceptions, and properly catching each type required studying both Python's exception system and MongoDB's error documentation. The enhanced database module now has the security, reliability, and performance features needed for a real production environment. This project taught me how important query optimization is for database systems, and how important a skill it is for any software engineer working with data-intensive applications.

---

Artifact enhancement files repository at [Databases - Animal Shelter Enhancement](https://github.com/nathanJohnson11/nathanJohnson11.github.io/tree/main/artifacts/Enhanced/CS340%20-%20Databases "View Enhanced Source Code")

---
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
